<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 512 HW4 - Textures</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }

    .texture-preview {
      width: 100px;
      height: 100px;
      border: 1px solid #666;
      margin: 5px 0;
      object-fit: cover;
    }
  </style>
</head>

<body>
  <h2>Interactive Controls & Hierarchy & Lighting & Textures</h2>
  <p><a href='https://github.com/invigoro/cs512-hw5'>View on Github</a></p>
  <p>
    Use mouse to drag and manipulate objects.<br>
    Use arrow keys and w, s keys to move the camera.<br>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: none; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
      <canvas id="glcanvas" width="900" height="600"></canvas>
    </div>
    <div>
      <div>
        <p>Click on a shape in the scene to manipulate it and add children!</p>
        <p>Transforming a shape will transform all its children.</p>
      </div>
      <div><label for="primitive">Choose a shape:</label>

        <select name="primitive" id="primitiveName">
          <option value="Cube">Cube</option>
          <option value="Tetrahedron">Tetrahedron</option>
          <option value="Cone">Cone</option>
          <option value="Cylinder">Cylinder</option>
          <option value="Sphere">Sphere</option>
          <option value="Torus">Torus</option>
        </select>
      </div>

      <button id="primitive-insert" onclick="createShape();">Add New Shape</button>
      <div>
        <p>Choose Transform Type</p>
        <button id="translate-button" onclick="setMode('translate')">Translate</button>
        <button id="rotate-button" onclick="setMode('rotate')">Rotate</button>
        <button id="scale-button" onclick="setMode('scale')">Scale</button>
      </div>
      <div>
        <p>Shading Mode</p>
        <button id="smooth-shading" onclick="setShadingMode('smooth')">Smooth Shading</button>
        <button id="flat-shading" onclick="setShadingMode('flat')">Flat Shading</button>
      </div>

      <div id="shape-properties" style="display: none;">
        <div id="shape-rotation-speed">
          <p>Rotation Speed</p>
          <label for="rot-x-speed">X</label>
          <input type="range" id="rot-x-speed" name="rot-x-speed" min="0" max="100" value="0">
          <label for="rot-y-speed">Y</label>
          <input type="range" id="rot-y-speed" name="rot-y-speed" min="0" max="100" value="0">
          <label for="rot-z-speed">Z</label>
          <input type="range" id="rot-z-speed" name="rot-z-speed" min="0" max="100" value="0">
        </div>
        <div id="shape-colors">
          <p>Colors</p>
          <label for="color-1">Primary</label>
          <input type="color" id="color-1">
          <label for="color-2">Secondary</label>
          <input type="color" id="color-2">
        </div>
        
        <div id="shape-material">
          <p>Material Properties</p>
          <div> <label for="ambient">Ambient: <span id="ambient-value">0.3</span></label>
            <input type="range" id="ambient" name="ambient" min="0" max="100" value="30" step="1">
          </div>
          <div>
            <label for="diffuse">Diffuse: <span id="diffuse-value">0.8</span></label>
            <input type="range" id="diffuse" name="diffuse" min="0" max="100" value="80" step="1">
          </div>
          <div>
            <label for="specular">Specular: <span id="specular-value">1.0</span></label>
            <input type="range" id="specular" name="specular" min="0" max="100" value="100" step="1">
          </div>
          <div>
            <label for="shininess">Shininess: <span id="shininess-value">32</span></label>
            <input type="range" id="shininess" name="shininess" min="1" max="128" value="32" step="1">
          </div>
        </div>

        <div id="shape-texture">
          <p>Texture Mapping</p>
          <div>
            <label>
              <input type="checkbox" id="use-texture">
              Enable Texture
            </label>
          </div>
          <div id="texture-controls" style="display: none;">
            <label for="texture-url">Texture URL:</label>
            <input type="text" id="texture-url" placeholder="Enter image URL" style="width: 200px;">
            <button id="load-texture">Load</button>
            <div>
              <label>Quick Select:</label><br>
              <div id="quick-texture-buttons"></div>
            </div>
            <img id="texture-preview" class="texture-preview" style="display: none;">
          </div>
        </div>

        <div id="shape-bump">
          <p>Bump Mapping</p>
          <div>
            <label>
              <input type="checkbox" id="use-bump">
              Enable Bump Map
            </label>
          </div>
          <div id="bump-controls" style="display: none;">
            <label for="bump-url">Bump Map URL:</label>
            <input type="text" id="bump-url" placeholder="Enter image URL" style="width: 200px;">
            <button id="load-bump">Load</button>
            <div>
              <label for="bump-strength">Strength: <span id="bump-strength-value">1.0</span></label>
              <input type="range" id="bump-strength" name="bump-strength" min="0" max="100" value="50" step="1">
            </div>
            <img id="bump-preview" class="texture-preview" style="display: none;">
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Vertex shader with texture support -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;
in vec3 aNormal;
in vec2 aTexCoord;

uniform float uTime;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;
uniform bool uFlatShading;

out vec3 vColor;
out vec3 vNormal;
out vec3 vFragPos;
out vec2 vTexCoord;
out vec3 vTangent;
out vec3 vBitangent;

// For flat shading
flat out vec3 vFlatNormal;
flat out vec3 vFlatColor;

void main() {
  vec4 worldPos = uModelTransformationMatrix * vec4(aPosition, 1.0);
  vFragPos = worldPos.xyz;
  
  mat3 normalMatrix = mat3(transpose(inverse(uModelTransformationMatrix)));
  vec3 transformedNormal = normalize(normalMatrix * aNormal);
  
  vNormal = transformedNormal;
  vFlatNormal = transformedNormal;
  
  vColor = aColor;
  vFlatColor = aColor;
  vTexCoord = aTexCoord;
  
  // Compute tangent and bitangent for bump mapping
  vec3 c1 = cross(transformedNormal, vec3(0.0, 0.0, 1.0));
  vec3 c2 = cross(transformedNormal, vec3(0.0, 1.0, 0.0));
  vTangent = length(c1) > length(c2) ? c1 : c2;
  vTangent = normalize(vTangent);
  vBitangent = normalize(cross(transformedNormal, vTangent));
  
  gl_Position = uProjectionMatrix * uModelViewMatrix * worldPos;
}
</script>
  <!-- Fragment Shader with textures and bump mapping -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 vColor;
in vec3 vNormal;
in vec3 vFragPos;
in vec2 vTexCoord;
in vec3 vTangent;
in vec3 vBitangent;

flat in vec3 vFlatNormal;
flat in vec3 vFlatColor;

uniform float uOpacity;
uniform vec3 uViewPos;
uniform bool uFlatShading;

uniform vec3 uLightPos1;
uniform vec3 uLightPos2;
uniform vec3 uLightColor1;
uniform vec3 uLightColor2;

uniform float uAmbient;
uniform float uDiffuse;
uniform float uSpecular;
uniform float uShininess;

// Texture uniforms
uniform bool uUseTexture;
uniform sampler2D uTexture;
uniform bool uUseBump;
uniform sampler2D uBumpMap;
uniform float uBumpStrength;

out vec4 fragColor;

vec3 calculatePointLight(vec3 lightPos, vec3 lightColor, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 objectColor) {
  vec3 lightDir = normalize(lightPos - fragPos);
  
  vec3 ambient = uAmbient * objectColor * lightColor;
  
  float diff = max(dot(normal, lightDir), 0.0);
  vec3 diffuse = uDiffuse * diff * objectColor * lightColor;
  
  vec3 halfwayDir = normalize(lightDir + viewDir);
  float spec = pow(max(dot(normal, halfwayDir), 0.0), uShininess);
  vec3 specular = uSpecular * spec * lightColor;
  
  return ambient + diffuse + specular;
}

vec3 perturbNormal(vec3 normal, vec3 tangent, vec3 bitangent, vec2 texCoord) {
  vec3 bumpSample = texture(uBumpMap, texCoord).rgb;
  vec3 bumpNormal = normalize(bumpSample * 2.0 - 1.0);
  bumpNormal.xy *= uBumpStrength;
  
  mat3 TBN = mat3(tangent, bitangent, normal);
  return normalize(TBN * bumpNormal);
}

void main() {
  vec3 norm = uFlatShading ? normalize(vFlatNormal) : normalize(vNormal);
  vec3 color = uFlatShading ? vFlatColor : vColor;
  
  // Apply texture if enabled
  if (uUseTexture) {
    vec3 texColor = texture(uTexture, vTexCoord).rgb;
    color = texColor;
  }
  
  // Apply bump mapping if enabled
  if (uUseBump && !uFlatShading) {
    norm = perturbNormal(norm, normalize(vTangent), normalize(vBitangent), vTexCoord);
  }
  
  vec3 viewDir = normalize(uViewPos - vFragPos);
  
  vec3 light1 = calculatePointLight(uLightPos1, uLightColor1, norm, vFragPos, viewDir, color);
  vec3 light2 = calculatePointLight(uLightPos2, uLightColor2, norm, vFragPos, viewDir, color);
  
  vec3 result = light1 + light2;
  
  fragColor = vec4(result, uOpacity);
}
</script>
  <script id="fragment-shader-pick" type="x-shader/x-fragment">#version 300 es
precision mediump float;
uniform vec3 uPickColor;
out vec4 fragColor;
void main() {
  fragColor = vec4(uPickColor, 1.0);
}
</script>

  <script src="primitives.js"></script>
  <script src="transformations.js"></script>
  <script src="planets.js"></script>
  <script src="texture-mapping.js"></script>
  <script src="event-listeners.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    let program, posLoc, colorLoc, normalLoc, texCoordLoc, uMVM, uPM, uMTM, uOpacityLoc;
    let uViewPos, uLightPos1, uLightPos2, uLightColor1, uLightColor2;
    let uAmbient, uDiffuse, uSpecular, uShininess, uFlatShading;
    let uUseTexture, uTexture, uUseBump, uBumpMap, uBumpStrength;
    let shapesGlobal = [];
    let selectedObject = null;
    let selectedObjectIndex = null;
    let curId = 0;
    let mode = "translate";
    let flatShading = false;
    

    
    function getNewId() {
      curId++;
      return curId;
    }
    
    function setMode(modeName) {
      mode = modeName;
    }
    
    function setShadingMode(shadingMode) {
      flatShading = (shadingMode === 'flat');
    }

    function initBuffer(positions, colors, indices, normals, texCoords) {
      let bvbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bvbo);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      let bnbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bnbo);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

      let bnorm = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, bnorm);
      gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

      let btex = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, btex);
      gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

      let bibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      return new shape(bvbo, bnbo, bibo, bnorm, btex, indices.length, positions.length / 3, getNewId(), colors.slice(0, 3), colors.slice(colors.length - 3));
    }

    function createShape(shapeName = null, parent = null) {
      if (shapeName == null) {
        shapeName = document.getElementById("primitiveName").value;
      }
      let shape = null;
      switch (shapeName) {
        case "Cube": shape = createCube(); break;
        case "Cylinder": shape = createCylinder(); break;
        case "Tetrahedron": shape = createTetrahedron(); break;
        case "Cone": shape = createCone(); break;
        case "Torus": shape = createTorus(); break;
        case "Sphere": shape = createSphere(); break;
      }
      let shapeBuffer = initBuffer(shape.positions, shape.colors, shape.indices, shape.normals, shape.texCoords);
      if (selectedObject) {
        selectedObject.children.push(shapeBuffer);
        shapeBuffer.parent = selectedObject;
      } else if(parent) {
        parent.children.push(shapeBuffer);
        shapeBuffer.parent = parent;
      } else {
        shapesGlobal.push(shapeBuffer);
      }
      return shapeBuffer;
    }

    function initAllBuffers() {
      shapesGlobal = [];
      drawPlanets();
    }
    initAllBuffers();

    function initShaderProgram() {
      try {
        program = createProgram(gl, vertEditor.value, fragEditor.value);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        normalLoc = gl.getAttribLocation(program, "aNormal");
        texCoordLoc = gl.getAttribLocation(program, "aTexCoord");
        uOpacityLoc = gl.getUniformLocation(program, "uOpacity");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");
        
        uViewPos = gl.getUniformLocation(program, "uViewPos");
        uLightPos1 = gl.getUniformLocation(program, "uLightPos1");
        uLightPos2 = gl.getUniformLocation(program, "uLightPos2");
        uLightColor1 = gl.getUniformLocation(program, "uLightColor1");
        uLightColor2 = gl.getUniformLocation(program, "uLightColor2");
        
        uAmbient = gl.getUniformLocation(program, "uAmbient");
        uDiffuse = gl.getUniformLocation(program, "uDiffuse");
        uSpecular = gl.getUniformLocation(program, "uSpecular");
        uShininess = gl.getUniformLocation(program, "uShininess");
        uFlatShading = gl.getUniformLocation(program, "uFlatShading");
        
        uUseTexture = gl.getUniformLocation(program, "uUseTexture");
        uTexture = gl.getUniformLocation(program, "uTexture");
        uUseBump = gl.getUniformLocation(program, "uUseBump");
        uBumpMap = gl.getUniformLocation(program, "uBumpMap");
        uBumpStrength = gl.getUniformLocation(program, "uBumpStrength");
      } catch (e) { console.error(e); }
    }
    initShaderProgram();

    let pickProgram, uPickColorLoc;

    function initPickShader() {
      const vsSource = document.getElementById("vertex-shader").textContent;
      const fsSource = document.getElementById("fragment-shader-pick").textContent;

      pickProgram = createProgram(gl, vsSource, fsSource);
      uPickColorLoc = gl.getUniformLocation(pickProgram, "uPickColor");
      uPickPM = gl.getUniformLocation(pickProgram, "uProjectionMatrix");
      uPickMVM = gl.getUniformLocation(pickProgram, "uModelViewMatrix");
      uPickMTM = gl.getUniformLocation(pickProgram, "uModelTransformationMatrix");
    }
    initPickShader();

    let pickFramebuffer = gl.createFramebuffer();
    let pickTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, pickTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    let depthBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, canvas.width, canvas.height);

    gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickTexture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;

    let mouseDown = false, lastX, lastY;
    let camX = 0, camY = 0, camZ = -6;

    
    let proj;
    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
    let f = 1 / Math.tan(fov / 2);
    proj = new Float32Array([
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (zFar + zNear) / (zNear - zFar), -1,
      0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    function findShapeById(id, shapeArray = shapesGlobal) {
      for (let s of shapeArray) {
        if (s.id === id) return s;
        if (s.children && s.children.length > 0) {
          let found = findShapeById(id, s.children);
          if (found) return found;
        }
      }
      return null;
    }

    function drawShapePickObject(s) {
      let transformMatrix = s.getFullTransformMatrix();
      gl.uniformMatrix4fv(uPickMTM, false, transformMatrix);

      gl.bindBuffer(gl.ARRAY_BUFFER, s.vbo);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s.ibo);

      gl.uniform3fv(uPickColorLoc, s.pickColor);
      gl.drawElements(gl.TRIANGLES, s.length, gl.UNSIGNED_SHORT, 0);
      if (s.children && s.children.length > 0) {
        for (let j = 0; j < s.children.length; j++) {
          drawShapePickObject(s.children[j]);
        }
      }
    }

    function pickObjectAt(x, y) {
      let mvMatrix = mat4Translate(mat4Identity(), [camX, camY, camZ]);

      gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.useProgram(pickProgram);
      gl.uniformMatrix4fv(uPickPM, false, proj);
      gl.uniformMatrix4fv(uPickMVM, false, mvMatrix);

      for (let i = 0; i < shapesGlobal.length; i++) {
        drawShapePickObject(shapesGlobal[i]);
      }

      let pixels = new Uint8Array(4);
      gl.readPixels(x, canvas.height - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      let pickedId = colorToId(pixels);
      return pickedId;
    }

    let startTime = Date.now();
    let time = startTime;
    let prevFrameTime = Date.now();
    let timeDiff = Date.now();
    let pulseOpacity = 1;

    function drawShapeInScene(s) {
      let transformMatrix = s.getFullTransformMatrix(selectedObject == null || s == selectedObject, timeDiff);
      
      let mat = s.material || {ambient: 0.3, diffuse: 0.8, specular: 1.0, shininess: 32.0};
      gl.uniform1f(uAmbient, mat.ambient);
      gl.uniform1f(uDiffuse, mat.diffuse);
      gl.uniform1f(uSpecular, mat.specular);
      gl.uniform1f(uShininess, mat.shininess);
      
      // Set texture uniforms
      gl.uniform1i(uUseTexture, s.useTexture && s.texture ? 1 : 0);
      if (s.useTexture && s.texture) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, s.texture);
        gl.uniform1i(uTexture, 0);
      }
      
      // Set bump map uniforms
      gl.uniform1i(uUseBump, s.useBump && s.bumpTexture ? 1 : 0);
      if (s.useBump && s.bumpTexture) {
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, s.bumpTexture);
        gl.uniform1i(uBumpMap, 1);
        gl.uniform1f(uBumpStrength, s.bumpStrength || 1.0);
      }
      
      if (s === selectedObject) {
        gl.uniform1f(uOpacityLoc, pulseOpacity);
      } else {
        gl.uniform1f(uOpacityLoc, 1.0);
      }
      
      gl.disable(gl.CULL_FACE);
      gl.uniformMatrix4fv(uMTM, false, transformMatrix);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, s.vbo);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, s.normalBuffer);
      gl.enableVertexAttribArray(normalLoc);
      gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, s.nbo);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, s.texCoordBuffer);
      gl.enableVertexAttribArray(texCoordLoc);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, s.ibo);
      gl.drawElements(gl.TRIANGLES, s.length, gl.UNSIGNED_SHORT, 0);

      if (s.children && s.children.length > 0) {
        for (let j = 0; j < s.children.length; j++) {
          drawShapeInScene(s.children[j]);
        }
      }
    }

    function render() {
      gl.useProgram(program);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      gl.uniformMatrix4fv(uPM, false, proj);

      let modelViewMatrix = mat4Translate(mat4Identity(), [camX, camY, camZ]);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);

      time = (Date.now() - startTime) / 1000;
      timeDiff = (Date.now() - prevFrameTime) / 1000;
      prevFrameTime = Date.now();
      pulseOpacity = 0.75 + 0.25 * Math.sin(time * 5);

      //for the gif(s)
      updateAnimatedTextures();

      gl.uniform3fv(uViewPos, [-camX, -camY, -camZ]);

      gl.uniform3fv(uLightPos1, [3, 5, 2]);
      gl.uniform3fv(uLightColor1, [1.0, 1.0, 1.0]);

      gl.uniform3fv(uLightPos2, [-4, 2, -1]);
      gl.uniform3fv(uLightColor2, [0.6, 0.7, 1.0]);

      gl.uniform1i(uFlatShading, flatShading ? 1 : 0);

      for (let i = 0; i < shapesGlobal.length; i++) {
        drawShapeInScene(shapesGlobal[i]);
      }
    }

    window.onload = function () {
      setInterval(render, 30);
    }

  </script>
</body>

</html>